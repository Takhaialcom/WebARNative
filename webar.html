<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Portal with Plane Detection</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #0ff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 12px;
            max-width: 90%;
        }
        
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 20px;
            background: #0080ff;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(0, 128, 255, 0.4);
            z-index: 10;
        }
        
        #startButton:active {
            background: #0066cc;
            transform: translate(-50%, -50%) scale(0.95);
        }
        
        #debugInfo {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 10px;
            border-radius: 5px;
            font-size: 10px;
            font-family: monospace;
            max-width: 90%;
            word-wrap: break-word;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="overlay">
        <button id="startButton">Start AR Portal</button>
        <div id="instructions" class="hidden">
            Move your device slowly to detect surfaces
        </div>
        <div id="status">Checking device compatibility...</div>
        <div id="debugInfo"></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Debug logging
        function log(message, isError = false) {
            const debugInfo = document.getElementById('debugInfo');
            const timestamp = new Date().toLocaleTimeString();
            const color = isError ? '#f00' : '#0f0';
            debugInfo.innerHTML += `<div style="color:${color}">[${timestamp}] ${message}</div>`;
            debugInfo.scrollTop = debugInfo.scrollHeight;
            console.log(message);
        }

        // Configuration
        const CONFIG = {
            portalSize: 1.5,
            portalColor: 0x00ffff,
            edgeGlowColor: 0x00ffff,
            rotationSpeed: 0.5,
            pulseSpeed: 2.0
        };

        // Global variables
        let camera, scene, renderer, reticle, portal;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let portalPlaced = false;
        let clock = new THREE.Clock();

        // UI elements
        const startButton = document.getElementById('startButton');
        const instructions = document.getElementById('instructions');
        const status = document.getElementById('status');

        // Portal destination scene
        let portalScene, portalCamera, portalTexture;

        function updateStatus(message) {
            status.textContent = message;
            status.classList.remove('hidden');
            log(message);
        }

        // Check WebXR support
        function checkWebXRSupport() {
            log('Checking WebXR support...');
            
            if (!navigator.xr) {
                log('WebXR not available', true);
                updateStatus('WebXR not supported. Use Chrome on Android or Safari 15+ on iOS');
                return false;
            }
            
            log('WebXR API found');
            
            navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                if (supported) {
                    log('AR mode supported!');
                    updateStatus('AR supported! Tap button to start');
                } else {
                    log('AR mode not supported', true);
                    updateStatus('AR not supported on this device');
                }
            }).catch((error) => {
                log('Error checking AR support: ' + error.message, true);
                updateStatus('Error checking AR support');
            });
            
            return true;
        }

        function init() {
            log('Initializing Three.js...');
            const container = document.getElementById('container');

            try {
                // Scene setup
                scene = new THREE.Scene();
                log('Scene created');

                // Camera setup
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
                log('Camera created');

                // Renderer setup
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.xr.enabled = true;
                container.appendChild(renderer.domElement);
                log('Renderer created and added to DOM');

                // Lighting
                const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
                light.position.set(0.5, 1, 0.25);
                scene.add(light);
                log('Lighting added');

                // Create reticle
                createReticle();
                log('Reticle created');

                // Create portal destination
                createPortalDestination();
                log('Portal destination created');

                // Window resize handler
                window.addEventListener('resize', onWindowResize);
                
                log('Initialization complete!');
                return true;
            } catch (error) {
                log('Error during initialization: ' + error.message, true);
                updateStatus('Error: ' + error.message);
                return false;
            }
        }

        function createReticle() {
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                side: THREE.DoubleSide,
                opacity: 0.8,
                transparent: true
            });
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
        }

        function createPortalDestination() {
            // Create separate scene for portal view
            portalScene = new THREE.Scene();
            portalScene.background = new THREE.Color(0x87ceeb);

            // Add lighting
            const portalLight = new THREE.DirectionalLight(0xffffff, 1);
            portalLight.position.set(5, 10, 5);
            portalScene.add(portalLight);
            portalScene.add(new THREE.AmbientLight(0x404040, 0.5));

            // Add ground
            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            portalScene.add(ground);

            // Add colorful cubes
            for (let i = 0; i < 10; i++) {
                const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const cubeMat = new THREE.MeshStandardMaterial({ 
                    color: Math.random() * 0xffffff 
                });
                const cube = new THREE.Mesh(cubeGeo, cubeMat);
                cube.position.set(
                    (Math.random() - 0.5) * 10,
                    0.25,
                    (Math.random() - 0.5) * 10
                );
                portalScene.add(cube);
            }

            // Portal camera
            portalCamera = new THREE.PerspectiveCamera(70, 1, 0.01, 100);
            portalCamera.position.set(0, 1.6, 3);
            portalCamera.lookAt(0, 1, 0);

            // Create render target
            portalTexture = new THREE.WebGLRenderTarget(512, 512, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter
            });
        }

        function createPortal(position) {
            log('Creating portal at position: ' + JSON.stringify(position));
            
            const portalGroup = new THREE.Group();
            portalGroup.position.copy(position);

            // Portal frame (ring)
            const frameGeo = new THREE.TorusGeometry(CONFIG.portalSize / 2, 0.05, 16, 32);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.portalColor,
                emissive: CONFIG.edgeGlowColor,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            portalGroup.add(frame);

            // Portal surface
            const surfaceGeo = new THREE.CircleGeometry(CONFIG.portalSize / 2, 32);
            const surfaceMat = new THREE.MeshBasicMaterial({ 
                map: portalTexture.texture,
                side: THREE.DoubleSide
            });
            const surface = new THREE.Mesh(surfaceGeo, surfaceMat);
            portalGroup.add(surface);

            // Outer glow ring
            const glowGeo = new THREE.TorusGeometry(CONFIG.portalSize / 2 + 0.1, 0.02, 16, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: CONFIG.edgeGlowColor,
                transparent: true,
                opacity: 0.6
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            portalGroup.add(glow);

            // Point light
            const portalLight = new THREE.PointLight(CONFIG.portalColor, 2, 5);
            portalLight.position.set(0, 0, 0.5);
            portalGroup.add(portalLight);

            // Add particles
            createPortalParticles(portalGroup);

            scene.add(portalGroup);
            portal = portalGroup;

            portal.userData = {
                frame: frame,
                surface: surface,
                glow: glow,
                light: portalLight,
                initialScale: portalGroup.scale.clone()
            };

            log('Portal created successfully!');
            updateStatus('Portal placed! View the magical world');
            
            setTimeout(() => {
                instructions.classList.add('hidden');
            }, 3000);
        }

        function createPortalParticles(parent) {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * CONFIG.portalSize / 2;
                positions[i] = Math.cos(angle) * radius;
                positions[i + 1] = (Math.random() - 0.5) * 0.5;
                positions[i + 2] = Math.sin(angle) * radius;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMat = new THREE.PointsMaterial({
                color: CONFIG.portalColor,
                size: 0.02,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMat);
            parent.add(particleSystem);
            parent.userData.particles = particleSystem;
        }

        function animatePortal() {
            if (!portal) return;

            const time = clock.getElapsedTime();
            const userData = portal.userData;

            // Rotate frame
            if (userData.frame) {
                userData.frame.rotation.z += CONFIG.rotationSpeed * 0.01;
            }

            // Pulse effect
            const pulse = 1 + Math.sin(time * CONFIG.pulseSpeed) * 0.1;
            portal.scale.copy(userData.initialScale).multiplyScalar(pulse);

            // Animate glow
            if (userData.glow) {
                userData.glow.material.opacity = 0.4 + Math.sin(time * 3) * 0.2;
            }

            // Animate light
            if (userData.light) {
                userData.light.intensity = 1.5 + Math.sin(time * 2) * 0.5;
            }

            // Rotate particles
            if (userData.particles) {
                userData.particles.rotation.z += 0.005;
            }
        }

        function updatePortalView() {
            if (!portal || !portalCamera) return;

            // Render portal destination
            renderer.setRenderTarget(portalTexture);
            renderer.render(portalScene, portalCamera);
            renderer.setRenderTarget(null);

            // Animate camera in portal world
            const time = clock.getElapsedTime();
            portalCamera.position.x = Math.sin(time * 0.5) * 2;
            portalCamera.position.z = 3 + Math.cos(time * 0.3);
            portalCamera.lookAt(0, 1, 0);
        }

        function onSelect() {
            if (reticle.visible && !portalPlaced) {
                log('User tapped to place portal');
                const position = new THREE.Vector3();
                position.setFromMatrixPosition(reticle.matrix);
                createPortal(position);
                portalPlaced = true;
                reticle.visible = false;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    log('Requesting hit test source...');
                    
                    // Try 'viewer' first, fallback to 'local' if not supported
                    const tryReferenceSpace = async (spaceType) => {
                        try {
                            const refSpace = await session.requestReferenceSpace(spaceType);
                            log(`Reference space '${spaceType}' acquired`);
                            return refSpace;
                        } catch (error) {
                            log(`Reference space '${spaceType}' not supported: ${error.message}`, true);
                            return null;
                        }
                    };
                    
                    (async () => {
                        let viewerSpace = await tryReferenceSpace('viewer');
                        if (!viewerSpace) {
                            viewerSpace = await tryReferenceSpace('local');
                        }
                        
                        if (viewerSpace) {
                            session.requestHitTestSource({ space: viewerSpace }).then((source) => {
                                hitTestSource = source;
                                log('Hit test source acquired successfully!');
                            }).catch((error) => {
                                log('Error getting hit test source: ' + error.message, true);
                            });
                        } else {
                            log('No compatible reference space found', true);
                            updateStatus('Device does not support hit testing');
                        }
                    })();

                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                        log('AR session ended');
                    });

                    hitTestSourceRequested = true;
                    updateStatus('Move device to detect surfaces');
                    instructions.classList.remove('hidden');
                }

                if (hitTestSource && !portalPlaced) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                        updateStatus('Tap screen to place portal');
                    } else {
                        reticle.visible = false;
                    }
                }

                animatePortal();
                updatePortalView();
            }

            renderer.render(scene, camera);
        }

        // Start button handler
        startButton.addEventListener('click', async () => {
            log('Start button clicked');
            startButton.classList.add('hidden');
            
            try {
                if (!navigator.xr) {
                    throw new Error('WebXR not available');
                }

                const supported = await navigator.xr.isSessionSupported('immersive-ar');
                
                if (!supported) {
                    throw new Error('AR not supported on this device');
                }

                log('Requesting AR session...');
                updateStatus('Starting AR session...');

                const sessionInit = {
                    requiredFeatures: ['hit-test'],
                    optionalFeatures: ['dom-overlay', 'local']
                };

                const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
                log('AR session granted');
                
                await renderer.xr.setSession(session);
                log('Renderer XR session set');
                
                session.addEventListener('select', onSelect);
                updateStatus('AR started! Move your device');
                
            } catch (error) {
                log('Error starting AR: ' + error.message, true);
                updateStatus('Error: ' + error.message);
                startButton.classList.remove('hidden');
                startButton.textContent = 'Retry AR Start';
            }
        });

        // Initialize on load
        window.addEventListener('load', () => {
            log('Page loaded');
            const initSuccess = init();
            if (initSuccess) {
                animate();
                checkWebXRSupport();
            }
        });
    </script>
</body>
</html>
