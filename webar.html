<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR Portal with Plane Detection</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
        }
        
        #status {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #0ff;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 20px;
            background: #0080ff;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(0, 128, 255, 0.4);
        }
        
        #startButton:hover {
            background: #0066cc;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="overlay">
        <button id="startButton">Start AR Experience</button>
        <div id="instructions" class="hidden">
            Move your device to detect surfaces, then tap to place portal
        </div>
        <div id="status" class="hidden">Initializing AR...</div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';

        // Configuration
        const CONFIG = {
            portalSize: 1.5,
            portalColor: 0x00ffff,
            edgeGlowColor: 0x00ffff,
            rotationSpeed: 0.5,
            pulseSpeed: 2.0
        };

        // Global variables
        let camera, scene, renderer, reticle, portal;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let portalPlaced = false;
        let clock = new THREE.Clock();

        // UI elements
        const startButton = document.getElementById('startButton');
        const instructions = document.getElementById('instructions');
        const status = document.getElementById('status');

        // Portal destination scene
        let portalScene, portalCamera, portalTexture;

        function init() {
            const container = document.getElementById('container');

            // Scene setup
            scene = new THREE.Scene();

            // Camera setup
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // Lighting
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            // Create reticle for plane detection
            createReticle();

            // Create portal destination scene
            createPortalDestination();

            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function createReticle() {
            const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            reticle = new THREE.Mesh(geometry, material);
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
        }

        function createPortalDestination() {
            // Create separate scene for portal view
            portalScene = new THREE.Scene();
            portalScene.background = new THREE.Color(0x87ceeb);

            // Add some objects to the portal world
            const portalLight = new THREE.DirectionalLight(0xffffff, 1);
            portalLight.position.set(5, 10, 5);
            portalScene.add(portalLight);
            portalScene.add(new THREE.AmbientLight(0x404040));

            // Add a colorful environment
            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x2d5016 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            portalScene.add(ground);

            // Add some cubes
            for (let i = 0; i < 10; i++) {
                const cubeGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const cubeMat = new THREE.MeshStandardMaterial({ 
                    color: Math.random() * 0xffffff 
                });
                const cube = new THREE.Mesh(cubeGeo, cubeMat);
                cube.position.set(
                    (Math.random() - 0.5) * 10,
                    0.25,
                    (Math.random() - 0.5) * 10
                );
                portalScene.add(cube);
            }

            // Portal camera
            portalCamera = new THREE.PerspectiveCamera(70, 1, 0.01, 100);
            portalCamera.position.set(0, 1.6, 3);
            portalCamera.lookAt(0, 1, 0);

            // Create render target for portal
            portalTexture = new THREE.WebGLRenderTarget(512, 512);
        }

        function createPortal(position) {
            const portalGroup = new THREE.Group();
            portalGroup.position.copy(position);

            // Portal frame (ring)
            const frameGeo = new THREE.TorusGeometry(CONFIG.portalSize / 2, 0.05, 16, 32);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: CONFIG.portalColor,
                emissive: CONFIG.edgeGlowColor,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            portalGroup.add(frame);

            // Portal surface (shows destination)
            const surfaceGeo = new THREE.CircleGeometry(CONFIG.portalSize / 2, 32);
            const surfaceMat = new THREE.MeshBasicMaterial({ 
                map: portalTexture.texture,
                side: THREE.DoubleSide
            });
            const surface = new THREE.Mesh(surfaceGeo, surfaceMat);
            portalGroup.add(surface);

            // Outer glow ring
            const glowGeo = new THREE.TorusGeometry(CONFIG.portalSize / 2 + 0.1, 0.02, 16, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: CONFIG.edgeGlowColor,
                transparent: true,
                opacity: 0.6
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            portalGroup.add(glow);

            // Add point light
            const portalLight = new THREE.PointLight(CONFIG.portalColor, 2, 5);
            portalLight.position.set(0, 0, 0.5);
            portalGroup.add(portalLight);

            // Add particle system
            createPortalParticles(portalGroup);

            scene.add(portalGroup);
            portal = portalGroup;

            // Store references for animation
            portal.userData = {
                frame: frame,
                surface: surface,
                glow: glow,
                light: portalLight,
                initialScale: portalGroup.scale.clone()
            };

            updateStatus('Portal placed! Walk through to teleport');
            setTimeout(() => {
                instructions.classList.add('hidden');
                status.classList.add('hidden');
            }, 3000);
        }

        function createPortalParticles(parent) {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * CONFIG.portalSize / 2;
                positions[i] = Math.cos(angle) * radius;
                positions[i + 1] = (Math.random() - 0.5) * 0.5;
                positions[i + 2] = Math.sin(angle) * radius;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMat = new THREE.PointsMaterial({
                color: CONFIG.portalColor,
                size: 0.02,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMat);
            parent.add(particleSystem);
            parent.userData.particles = particleSystem;
        }

        function animatePortal() {
            if (!portal) return;

            const time = clock.getElapsedTime();
            const userData = portal.userData;

            // Rotate frame
            if (userData.frame) {
                userData.frame.rotation.z += CONFIG.rotationSpeed * 0.01;
            }

            // Pulse effect
            const pulse = 1 + Math.sin(time * CONFIG.pulseSpeed) * 0.1;
            portal.scale.copy(userData.initialScale).multiplyScalar(pulse);

            // Animate glow
            if (userData.glow) {
                userData.glow.material.opacity = 0.4 + Math.sin(time * 3) * 0.2;
            }

            // Animate light
            if (userData.light) {
                userData.light.intensity = 1.5 + Math.sin(time * 2) * 0.5;
            }

            // Rotate particles
            if (userData.particles) {
                userData.particles.rotation.z += 0.005;
            }
        }

        function updatePortalView() {
            if (!portal || !portalCamera) return;

            // Render portal destination to texture
            renderer.setRenderTarget(portalTexture);
            renderer.render(portalScene, portalCamera);
            renderer.setRenderTarget(null);

            // Simple camera movement in portal world
            const time = clock.getElapsedTime();
            portalCamera.position.x = Math.sin(time * 0.5) * 2;
            portalCamera.position.z = 3 + Math.cos(time * 0.3);
            portalCamera.lookAt(0, 1, 0);
        }

        function onSelect() {
            if (reticle.visible && !portalPlaced) {
                const position = new THREE.Vector3();
                position.setFromMatrixPosition(reticle.matrix);
                createPortal(position);
                portalPlaced = true;
                reticle.visible = false;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateStatus(message) {
            status.textContent = message;
            status.classList.remove('hidden');
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then((referenceSpace) => {
                        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
                            hitTestSource = source;
                        });
                    });

                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });

                    hitTestSourceRequested = true;
                    updateStatus('Move device to detect surfaces');
                    instructions.classList.remove('hidden');
                }

                if (hitTestSource && !portalPlaced) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
                        updateStatus('Tap to place portal');
                    } else {
                        reticle.visible = false;
                    }
                }

                // Animate portal
                animatePortal();
                updatePortalView();
            }

            renderer.render(scene, camera);
        }

        // Start button handler
        startButton.addEventListener('click', () => {
            startButton.classList.add('hidden');
            
            if (navigator.xr) {
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        const sessionInit = {
                            requiredFeatures: ['hit-test'],
                            optionalFeatures: ['dom-overlay'],
                            domOverlay: { root: document.getElementById('overlay') }
                        };

                        navigator.xr.requestSession('immersive-ar', sessionInit).then((session) => {
                            renderer.xr.setSession(session);
                            session.addEventListener('select', onSelect);
                            updateStatus('AR Session started');
                        }).catch((error) => {
                            updateStatus('Error starting AR: ' + error.message);
                        });
                    } else {
                        updateStatus('AR not supported on this device');
                    }
                });
            } else {
                updateStatus('WebXR not available. Use Chrome on Android or Safari on iOS 15+');
            }
        });

        // Initialize
        init();
        animate();
    </script>
</body>
</html>